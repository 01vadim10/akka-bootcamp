# Lesson 2.5: Using `Stash` to Defer Processing of Messages

At the end of [Lesson 4](../lesson4/) we discovered a significant bug in how we implemented the **Pause / Resume** functionality on live charts, as you can see below:

![Lesson 4 Output Bugs](../images/dothis-fail4.gif)

The bug is that when our `ChartingActor` changes its behavior to `Paused`, it no longer processes the `AddSeries` and `RemoveSeries` messages generated by the `PerformanceCounterCoordinatorActor` whenever a toggle button is pressed for a particular performance counter.

In it's current state,  it doesn't take much for the visual state of the buttons to get completely out of sync with the live chart - all you have to do is press a toggle button when the graph is paused.

So how can we fix this?

The answer is by using the [`Stash`](http://getakka.net/wiki/Stash) to defer processing of `AddSeries` and `RemoveSeries` messages until the `ChartingActor` is back in its `Charting` behavior.

## Key Concepts / Background

One of the side effects of switchable behavior for actors is that some behaviors may not be able to process specific types of messages. For instance, let's consider the authentication example we used for behavior-switching in [Lesson 4](../lesson4/).

### Real-World Scenario: Authentication with Buffering of Messages

This is the `UserActor` we designed in the Concepts area of lesson 4, with behavior switching for different states of authentication:

```csharp
public class UserActor : ReceiveActor{
	private readonly string _userId;
	private readonly string _chatRoomId;

	public UserActor(string userId, string chatRoomId){
		_userId = userId;
		_chatRoomId = chatRoomId;
		
		//start with the Authenticating behavior
		Authenticating();
	}

	protected override void PreStart(){
		//start the authentication process for this user
		Context.ActorSelection("/user/authenticator/")
			.Tell(new AuthenticatePlease(_userId));
	}

	private void Authenticating(){
		Receive<AuthenticationSuccess>(auth => {
			Become(Authenticated); //switch behavior to Authenticated
		});
		Receive<AuthenticationFailure>(auth => {
			Become(Unauthenticated); //switch behavior to Unauthenticated
		});
		Receive<IncomingMessage>(inc => inc.ChatRoomId == _chatRoomId,
			inc => { 
				// can't accept message yet - not auth'd
			});
		Receive<OutgoingMessage>(inc => inc.ChatRoomId == _chatRoomId,
			inc => { 
				// can't send message yet - not auth'd			
			});
	}

	private void Unauthenticated(){
		//switch to Authenticating
		Receive<RetryAuthentication>(retry => Become(Authenticating));
		Receive<IncomingMessage>(inc => inc.ChatRoomId == _chatRoomId,
			inc => { 
				// have to reject message - auth failed
			});
		Receive<OutgoingMessage>(inc => inc.ChatRoomId == _chatRoomId,
			inc => { 
				// have to reject message - auth failed	
			});
	}

	private void Authenticated(){
		Receive<IncomingMessage>(inc => inc.ChatRoomId == _chatRoomId,
			inc => { 
				// print message for user
			});
		Receive<OutgoingMessage>(inc => inc.ChatRoomId == _chatRoomId,
			inc => { 
				// send message to chatroom				
			});
	}
}
```

A major flaw with the `UserActor` in its present design: during the `Authenticating` phase we simply throw away any attempted `OutgoingMessage` and `IncomingMessage` instances. We're effectively losing any messages the user receives from or sends to the server for no good reason. **Yuck!**

A better way of dealing with this problem is to [use a `Stash` with our Akka.NET Actor](http://getakka.net/wiki/Stash) to temporarily store any of those messages until the `UserActor` enters either the `Authenticated` or `Unauthenticated` state.

### `WithBoundedStash` and `WithUnboundedStash`

To add a `Stash` to our actor, all we need to do is decorate it with the `WithBoundedStash` or `WithUnboundedStash` interface.


```csharp
public class UserActor : ReceiveActor, WithUnboundedStash{
	private readonly string _userId;
	private readonly string _chatRoomId;
	
	//added as part of WithUnboundedStash interface
	public IStash Stash {get;set;}
	
	//constructors, behaviors, etc...

}
```

But wait a minute, there's a new `Stash` property on the `UserActor` that includes a public getter and setter - does this mean that we have to initialize `Stash` ourselves? **NO!**

> The `Stash` property is automatically populated by an Akka.NET feature known as the "Actor Construction Pipeline," which gets used every time an actor is created locally (the details are beyond the scope of this lesson.) 

When Akka.NET sees a `WithBoundedStash` interface on your actors it knows to automatically populate a `BoundedStash` inside it's `Stash` property. Likewise, if it sees a `WithUnboundedStash` interface it knows to populate a `UnboundedStash` there instead.

#### When do we want a `BoundedStash` vs. an `UnboundedStash`

99% of the time you are going to want to use `UnboundedStash` - which allows your `Stash` to accept an unlimited number of messages. a `BoundedStash` should only be used when you want to set a maximum number of messages that can be stashed at any given time - your actor will crash whenever your `Stash` exceeds the limit of your `BoundedStash`.

### How `Stash` Works

So now that we've added a `Stash` to `UserActor`, how do we actually use it to store messages and release previously stored messages?

When your actor uses a `Stash`, it adds a message stack to the actor's ephemeral state - it would be the same as if you added your own `Stack<Envelope>` to your actor and managed it yourself.

#### Stashing Messages

![Stashing Messages with Akka.NET Actors](images/actors-stashing-messages.gif)

Inside your actor's `OnReceive` or `Receive<T>` handler, you can call `Stash.Stash()` to put the current message at the top of it's `Stash`, which is implemented as a stack-like data structure.

You only need to stash messages that you don't want to process now - in this example our actor happily processes Message 1 and stashes messages 2 and 0.

#### Unstashing a Single Message

![Unstashing a Single Message with Akka.NET Actors](images/actor-unstashing-single-message.gif)

We can call `Stash.Unstash()` to pop the message at the top of the `Stash` off of its stack, and here's where some of the `Stash`'s special behavior kicks in: **the `Stash` will place this message *at the front of the actor's mailbox, ahead of other queued messages*.**

When you add a `Stash` to your actor, you have the ability to change the FIFO order that mailboxes normally try to preserve.

#### Unstashing the Entire Stash at Once

![Unstashing all stashed messages at once with Akka.NET Actors](images/actor-unstashing-all-messages.gif)

If we need to unstash *everything* in our actor's `Stash` all at once, we can use the `Stash.UnstashAll()` method to push the entire contents of the `Stash` into the mailbox - but notice the message order is different than if we called `Stash.Unstash()` every time until the `Stash` emptied.

When you make a call to `Stash.UnstashAll()`, the `Stash` will ensure that the original FIFO order of the messages in the `Stash` is preserved when they're appended to the front of your actor's mailbox.

#### What Happens to the Messages in an Actor's `Stash` During Restarts?

A an excellent question - the `Stash` is part of your actor's ephemeral state. Unlike the actor's mailbox, which doesn't lose any messages during restarts - your stash will be destroyed and garbage collected.

***However*, you can preserve the contents of your `Stash` during restarts by calling `Stash.UnstashAll()` inside your actor's `PreRestart` lifecycle method**:

```csharp
protected override void PreRestart(Exception reason, object message){
	Stash.UnstashAll();	
}
```

### Using `Stash` in Our Authentication Example

So let's revisit the `UserActor` and solve the problem with throwing away messages during the `Authentication` behavior...

```csharp
public class UserActor : ReceiveActor{
	private readonly string _userId;
	private readonly string _chatRoomId;

	public UserActor(string userId, string chatRoomId){
		_userId = userId;
		_chatRoomId = chatRoomId;
		
		//start with the Authenticating behavior
		Authenticating();
	}

	protected override void PreStart(){
		//start the authentication process for this user
		Context.ActorSelection("/user/authenticator/")
			.Tell(new AuthenticatePlease(_userId));
	}

	private void Authenticating(){
		Receive<AuthenticationSuccess>(auth => {
			Become(Authenticated); //switch behavior to Authenticated
			Stash.UnstashAll(); //release all messages
		});
		Receive<AuthenticationFailure>(auth => {
			Become(Unauthenticated); //switch behavior to Unauthenticated
			Stash.UnstashAll(); //release all messages
		});
		Receive<IncomingMessage>(inc => inc.ChatRoomId == _chatRoomId,
			inc => { 
				//save this message for later
				Stash.Stash();
			});
		Receive<OutgoingMessage>(inc => inc.ChatRoomId == _chatRoomId,
			inc => { 
				//save this message for later
				Stash.Stash();
			});
	}

	private void Unauthenticated(){
		//switch to Authenticating
		Receive<RetryAuthentication>(retry => Become(Authenticating));
		Receive<IncomingMessage>(inc => inc.ChatRoomId == _chatRoomId,
			inc => { 
				// have to reject message - auth failed
			});
		Receive<OutgoingMessage>(inc => inc.ChatRoomId == _chatRoomId,
			inc => { 
				// have to reject message - auth failed	
			});
	}

	private void Authenticated(){
		Receive<IncomingMessage>(inc => inc.ChatRoomId == _chatRoomId,
			inc => { 
				// print message for user
			});
		Receive<OutgoingMessage>(inc => inc.ChatRoomId == _chatRoomId,
			inc => { 
				// send message to chatroom				
			});
	}
}
```

With this addition to the codebase, any messages the `UserActor` received while it was in its `Authenticating` behavior will now be available to it when it switches behavior to `Authentiated` or `Unauthenticated`.

## Exercise
In this lesson we're going to fix the **Pause / Resume** bug we introduced at the end of Lesson 4 inside the `ChartingActor` by using an `UnboundedStash`.

### Phase 1 - Have the `ChartingActor` Implement the `WithUnboundedStash` Interface

Inside `Actors/ChartingActor.cs` update the `ChartingActor` class declaration and have it implement the `WithUnboundedStash` interface:

```csharp
// Actors/ChartingActor.cs
public class ChartingActor : ReceiveActor, WithUnboundedStash
```

Also, implement the interface and have it add the following property somewhere inside `ChartingActor`:

```csharp
// Actors/ChartingActor.cs - inside ChartingActor class definition
public IStash Stash { get; set; }
```

### Phase 2 - Add `Stash` Method Calls to `Receive<T>` Handlers Inside `Paused()` Behavior

Go to the `Paused()` method declared inside `ChartingActor` and make the following changes:

```csharp
// Actors/ChartingActor.cs - inside ChartingActor class definition
private void Paused()
{
    Receive<AddSeries>(addSeries => Stash.Stash());
    Receive<RemoveSeries>(removeSeries => Stash.Stash());
    Receive<Metric>(metric => HandleMetricsPaused(metric));
    Receive<TogglePause>(pause =>
    {
        SetPauseButtonText(false);
        Unbecome();
        Stash.UnstashAll();
    });
}
```
That's it! The `ChartingActor` will now save any `AddSeries` or `RemoveSeries` messages and will replay them in the order they were received as soon as the `ChartingActor` switches back to its `Charting()` behavior.

The bug should now be fixed!

### Once you're done
Build and run `SystemCharting.sln` and you should see the following:

![Successful Unit 2 Output](images/syncharting-complete-output.gif)

Compare your code to the code in the [/Completed/ folder](Completed/) to compare your final output to what the instructors produced.

## Great job!

### Wohoo! You did it! Unit 2 is complete! Now go enjoy a well-deserved break, and gear up for Unit 3!

[Sign up here for email updates for when Unit 3 is ready](http://learnakka.net/)!
